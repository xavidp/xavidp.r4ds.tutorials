---
title: Importar y Exportar Datos
author: David Kane (traducido por Xavier de Pedro)
tutorial:
  id: data-import
output:
  learnr::tutorial:
    language: es    
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Tutorial para el capítulo 8: Importar Datos'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)
library(janitor)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

estudiantes <- read_csv("data/students.csv")

estudiantes2 <- estudiantes |> 
  clean_names() |> 
  mutate(
    meal_plan = factor(meal_plan),
    age = if_else(age == "five", "5", age),
    age = parse_number(age)
  )

simple_csv <- "
  x
  10
  .
  20
  30"

another_csv <- "
x,y,z
1,2,3"
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

## Introducción
### 

Este tutorial cubre el [Capítulo 8: Importar Datos](https://r4ds.hadley.nz/data-import.html) del libro [*R for Data Science (2e)*](https://r4ds.hadley.nz/) por Hadley Wickham, Mine Çetinkaya-Rundel, y Garrett Grolemund. Aprenderás como importar datos en tu proyecto de R usando [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.html) y funciones relacionadas del paquete [**readr**](https://readr.tidyverse.org/). También aprenderás como escribir datos a archivos con funciones como [`write_csv()`](https://readr.tidyverse.org/reference/write_delim.html).




## Lectura de datos de un archivo
###

Esta sección proporciona consejos prácticos para manejar funciones como nombres de columnas, tipos y datos faltantes.


### Ejercicio 1

[**readr**](https://readr.tidyverse.org/) es el paquete clave para leer datos. Carga **readr** escribiendo `library(readr)` en tu Consola. Luego ejecuta `help(package = "readr")`. Copia y pega el primer encabezado a continuación. (Debe ser una sola línea que haga referencia al número de versión).

```{r reading-data-from-a--1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edita la Respuesta",
	incorrect = NULL,
	rows = 1)
```

### 

Debido a que **readr** es uno de los 8 paquetes básicos en el *Tidyverse*, rara vez lo cargamos directamente. En su lugar, ejecutamos `library(tidyverse)` que carga los 8 paquetes.


### Ejercicio 2

Carga **tidyverse** escribiendo `library(tidyverse)` en tu Consola. Luego ejecuta `help(package = "tidyverse")`. Copia y pega el primer encabezado a continuación. (Debe ser una sola línea que haga referencia al número de versión).

```{r reading-data-from-a--2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edita la Respuesta",
	incorrect = NULL,
	rows = 1)
```

### 

Ten en cuenta la distinción entre *Tidyverse* (en mayúsculas y en cursiva) y **tidyverse** (sin mayúsculas y en negrita). Este último se refiere a un paquete R real, el que usamos casi cada vez que usamos R. Este último tiene un [significado general](https://www.tidyverse.org/):

> El tidyverse es una colección subjetiva de paquetes de R diseñados para la ciencia de datos usando R Moderno. Todos los paquetes comparten una filosofía de diseño, gramática y estructuras de datos subyacentes.

El "núcleo" del *Tidyverse* son los 8 paquetes cargados por `library(tidyverse)` pero el universo más amplio de *Tidyverse* incluye [muchos más paquetes](https://www.tidyverse.org/packages/) que comparten la mismo filosofía general.

### Ejercicio 3

Considera estos datos:

```{r message = FALSE, comment = ''}
read_lines("data/students.csv") |> cat(sep = "\n")
```

### 

Escribe código para leer estos datos en R. Usa `read_csv()` y establece el argumento `file` a "data/students.csv". Todos los archivos que usaremos en este tutorial se encuentran en el directorio `data/`.

```{r reading-data-from-a--3, exercise = TRUE}

```

```{r reading-data-from-a--3-hint-1, eval = FALSE}
read_csv(file = ...)
```

### 

Cuando ejecutas read_csv(), se muestra por pantalla un mensaje que te indica el número de filas y columnas de datos, el delimitador que se usó y las especificaciones de las columnas (nombres de columnas organizados por el tipo de datos que contiene la columna). También se muestra información sobre cómo recuperar la especificación de columna completa y cómo silenciar este mensaje.

### Ejercicio 4

En lugar de simplemente leer el archivo y luego simplemente "volcar" los resultados en la pantalla, ejecuta el mismo código anterior pero asigna el resultado a un nuevo objeto, `estudiantes`.


```{r reading-data-from-a--4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a--4-hint-1, eval = FALSE}
estudiantes <- read_csv(file = ...)
```

### 

Hay dos modos principales de hacer análisis de datos. En el primero, escribimos una serie de declaraciones, conectadas con canalizacones (también llamadas a veces "tuberías", de _pipe_ en inglés), que "descargan" sus resultados directamente en la pantalla. Este enfoque es útil para el análisis interactivo. En el segundo, que suele venir después, asignamos los resultados de los comandos a un objeto, como `estudiantes`, con el que trabajaremos más adelante.

### 

Ten en cuenta que hay dos formas principales de escribir canalizaciones ( _Pipes_ ) para conectar instrucciones de R. 

1. Durante muchos años se ha usado en R moderno la sintaxis `datos %>% instrucción1 %>% instrucción2` (usando ` %>% ` como canalizacion/_pipe_) segun se usaba en el paquete `magrittr` 

1. Más recientemente se está volviendo al uso en R Moderno de la sintaxis que ya contemplaba R base para las canalizaciones de instrucciones: `datos  |> instrucción1  |> instrucción2` (usando `  |> ` como canalizacion/_pipe_).

En internet podrás encontrar ejemplos usando las dos. En estos tutoriales se suele usar ` |> `, siguiendo la tendencia actual de evolución del R Moderno.

### Ejercicio 5

Muestra por pantalla el objeto `estudiantes`.

```{r reading-data-from-a--5, exercise = TRUE}

```

```{r reading-data-from-a--5-hint-1, eval = FALSE}
estudiantes
```

### 

En la columna `favourite.food`, hay un montón de alimentos, y luego la cadena de caracteres (texto) "N/A", que debería haber sido un NA real (dato que falta, _NA_ de _N_on _A_vailable en inglès) que R reconocerá como "no disponible". Esto es algo que podemos abordar usando el argumento `na`.

### Ejercicio 6

De forma predeterminada, `read_csv()` solo reconoce cadenas vacías ("") en este conjunto de datos como NA. Queremos que también reconozca la cadena de caracteres "N/A". Ejecuta `read_csv()` en "data/students.csv", estableciendo el argumento `na` a 'c("N/A", "")'


```{r reading-data-from-a--6, exercise = TRUE}

```

```{r reading-data-from-a--6-hint-1, eval = FALSE}
estudiantes <- read_csv(file = ...,
                     na = ...)
```

### 

Hay un conjunto muy diverso de formas que diferentes personas usarán para indicar, con cadenas de caracteres diferentes, que faltan datos. Mira cuidadosamente tus datos para encontrarlos todos.

### Ejercicio 7

También puedes notar que las columnas ID del estudiante y Nombre completo están rodeadas de acentos graves (acentos abiertos). Eso es porque contienen espacios, rompiendo las reglas usuales de R para nombres de variables; son nombres *no sintácticos*. Para hacer referencia a estas variables, debes rodearlas con acentos graves, `` ` ``.

Canaliza `estudiantes` a la función `rename()`, con "student_id = `Student ID`" como argumento.

```{r reading-data-from-a--7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a--7-hint-1, eval = FALSE}
estudiantes |> 
  rename(... = `Student ID)
```

### 

Esto corrige el nombre de la variable `Student ID` (`ID del estudiante`), pero todavía tenemos que lidiar con `Full Name` (`Nombre completo`). A veces, un conjunto de datos tendrá decenas de variables con nombres extraños. En ese caso, recomendamos usar la función `clean_names()` del paquete [**janitor**](https://sfirke.github.io/janitor/).


### Ejercicio 8

El paquete [**janitor**](https://sfirke.github.io/janitor/) también se usa habitualmente para limpiar nombres de variables. Carga el paquete en memoria a continuación. *Nota*: No se mostrará nada si el código se ejecuta correctamente.

```{r reading-data-from-a--8, exercise = TRUE}

```

```{r reading-data-from-a--8-hint-1, eval = FALSE}
library(janitor)
```

**janitor** ("conserje", en inglés) tiene varias funciones útiles, incluida `make_clean_names()`, que hace lo mismo que `clean_names()` pero se puede usar directamente durante la importación de datos en lugar de como parte de una canalización.


### Ejercicio 9

Canaliza `estudiantes` a `clean_names()`.

```{r reading-data-from-a--9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a--9-hint-1, eval = FALSE}
estudiantes |> 
  clean_names()
```

### 

`clean_names()` no solo corrige los nombres *no sintácticos* como `Full Name`; también limpia cualquier nombre de variable que no siga el enfoque estándar de, primero, no usar mayúsculas y, segundo, usar guiones bajos como separador de palabras. Fíjate cómo `favourite.food` se convierte en `favourite_food` y `mealPlan` se convierte en `meal_plan`


### Ejercicio 10

Otra tarea común después de leer datos es considerar tipos de variables. Por ejemplo, Meal_plan es una variable categórica con un conjunto conocido de valores posibles, que en R debe representarse como un factor. Continúa la canalización agregando una llamada a `mutate()`, con `meal_plan = factor(meal_plan)'.

```{r reading-data-from-a--10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a--10-hint-1, eval = FALSE}
estudiantes |> 
  clean_names() |> 
  mutate(meal_plan = ...(meal_plan))
```

### 

Ten en cuenta que los valores en la variable `meal_plan` se han mantenido iguales, pero el tipo de variable indicado debajo del nombre de la variable ha cambiado de carácter (`<chr>`) a factor (`<fct>`).


### Ejercicio 11

Antes de analizar estos datos, probablemente querrás arreglar la columna `age`. Actualmente, `age` es una variable de tipo carácter porque una de las observaciones se escribe como `five` en lugar de `5` numérico.
Continúa la canalización agregando una nueva línea a tu llamada a `mutate()` en la que redefinas `age` con
`age = if_else(age == "five", "5", age)`

```{r reading-data-from-a--11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a--11-hint-1, eval = FALSE}
estudiantes |> 
  clean_names() |> 
  mutate(
    meal_plan = factor(meal_plan),
    age = ...(age == "five", "5", age)
  )
```

### 

Una nueva función aquí es `if_else()`, que tiene tres argumentos. El primer argumento `test` debe ser un vector lógico. El resultado contendrá el valor del segundo argumento, `yes`, cuando test es `TRUE`, y el valor del tercer argumento, `no`, cuando es `FALSE`. Aquí estamos diciendo que si `age` es igual a la cadena de caracteres "cinco", conviértela en "5", y si no, déjela como `age`.

### Ejercicio 12

El resultado de la canalización todavía muestra `age` como una variable de carácter. Pero sabemos que `age` es un número. El R Moderno tiene una colección de funciones `parse_*` que transforman tipos de variables. Continúa con la canalización agregando una tercera línea a la instrucción `mutate()`: `age = parse_name(age)`. No olvides separar los diferentes pasos de dentro de la función `mutate()` con comas.

```{r reading-data-from-a--12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a--12-hint-1, eval = FALSE}
estudiantes |> 
  clean_names() |> 
  mutate(
    meal_plan = factor(meal_plan),
    age = if_else(age == "five", "5", age),
    age = ...(age)
  )
```

### 

Podríamos combinar las dos manipulaciones de `age` en una sola línea dentro de `mutate()` como:

> `age = parse_number(if_else(age == "five", "5", age))`

Pero a menudo es más fácil construir una canalización paso a paso, verificando que cada parte esté haciendo lo que deseas antes de continuar.


### Ejercicio 13

"CSV" significa **c**omma-**s**eparated **v**alues (**v**alores **s**eparados por **c**omas), lo que significa que los nombres de las variables y los valores de los datos están separados por comas en el archivo. Y cuando algun campo de datos contenga el caracter coma dentro, todo ese campo de datos concretos se rodeará de dobles comillas, para que la coma de dentro no sea interpretada como un separador de campo, sinó como un carácter cualquiera más de dentro de ese campo concreto.

Considera el contenido del archivo `test_1.csv`.

```{r comment = ''}
cat(readLines("data/test_1.csv"), sep = "\n")
```

### 

Escribe código para leer este archivo en R usando `read_csv()`, estableciendo el argumento `file` a "data/test_1.csv".

```{r reading-data-from-a--13, exercise = TRUE}

```

```{r reading-data-from-a--13-hint-1, eval = FALSE}
Usa read_csv() para leer de un archivo csv. 
Pon el argumento `file` a "data/test_1.csv".
```

```{r reading-data-from-a--13-hint-2, eval = FALSE}
read_csv(file = "data/test_1.csv")
```

### 

El resultado de ejecutar tu código debería parecerse a esto:

```{r comment = ''}
read_csv("data/test_1.csv")
```

### 

Trabajar con R de forma interactiva es como tener una conversación. Le dices algo a R y luego R responde algo. En este caso, le dices: "Lee este archivo". R te responde con "Estos datos tienen dos filas y tres columnas". El tamaño de un conjunto de datos es donde comienza la conversación.

###

El R Moderno del tidyverse luego te proporciona información sobre las columnas en el conjunto de datos. El mensaje de especificación de columna es una *sugerencia* de R para que especifiques los tipos de datos para cada columna de datos. R "adivina" un tipo de datos mientras no usemos el argumento `col_types`.


### Ejercicio 14

Haz que el mensaje desaparezca poniendo el argumento `show_col_types` a `FALSE`.

```{r reading-data-from-a--14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a--14-hint-1, eval = FALSE}
read_csv(file = "data/test_1.csv",
         show_col_types = ...)
```

### 

Hacer clic sobre "Run Code" debería generarte esta salida:

```{r comment = ''}
read_csv("data/test_1.csv",
         show_col_types = FALSE)
```

### 

Siempre es mejor usar el argumento `col_types` explícitamente para asegurarse de que los tipos de variables sean los que quieres que sean.

R está tratando de ser útil mostrándote ese mensaje. Te está sugiriendo "¿No deseas especificar los tipos de columna para estos datos? ¡Sería una buena idea!"


### Ejercicio 15

Considera el contenido del archivo `test_2.csv`.

```{r comment = ''}
cat(readLines("data/test_2.csv"), sep = "\n")
```

### 

Escriba código para omitir el texto en la parte superior de `"data/test_2.csv"` poniendo el segundo argumento `skip` al número apropiado.

```{r reading-data-from-a--15, exercise = TRUE}

```

```{r reading-data-from-a--15-hint-1, eval = FALSE}
Además del argumento `file`, necesitarás usar
el argumento `skip` aquí. Pon `skip` a 2.
```

```{r reading-data-from-a--15-hint-2, eval = FALSE}
read_csv(file = "data/test_2.csv",
          skip = ...)
```

### 

El resultado cuando se ejecute tu código debería verse así:

```{r comment = ''}
read_csv("data/test_2.csv",
         skip = 2)
```

### 

El argumento `skip` se usa para saltar filas, pero para saltar columnas, puedes usar la función `col_only()` como argumento para `col_types` para leer solo las columnas que desees.

### Ejercicio 16

Considera el contenido del archivo `test_3.csv`.

```{r comment = ''}
cat(readLines("data/test_3.csv"), sep = "\n")
```

### 

Escribe el código que creará nombres predeterminados para `"data/test_3.csv"` estableciendo el argumento `col_names` a `FALSE`.

```{r reading-data-from-a--16, exercise = TRUE}

```

```{r reading-data-from-a--16-hint-1, eval = FALSE}
Usa el argumento `col_names` y ponlo a FALSE
```

```{r reading-data-from-a--16-hint-2, eval = FALSE}
read_csv(file = "data/test_3.csv",
          col_names = ...)
```

### 

El resultado cuando se ejecuta tu código debería verse así:

```{r comment = ''}
read_csv("data/test_3.csv",
         col_names = FALSE)
```

### 

El argumento `col_names` también se puede usar para crear nombres de columna personalizados.

### Ejercicio 17

Considera, de nuevo, el contenido del archivo `test_3.csv`.

```{r comment = ''}
cat(readLines("data/test_3.csv"), sep = "\n")
```

### 

<!-- Using `col_names`, write code that will name the columns `a`, `b` and `c`.  -->

Establece el argumento `col_names` a un vector que contenga los nombres de columna `"a"`, `"b"` y `"c"`.

```{r reading-data-from-a--17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a--17-hint-1, eval = FALSE}
Usa el argumento `col_names` y ponlo a c("a", "b", "c").
```

### 

El resultado cuando se ejecute tu código debería verse así:

```{r comment = ''}
read_csv("data/test_3.csv",
         col_names = (c("a", "b", "c")))
```

### 

`col_names` no solo es específico de `read_csv()`, puede usarse en otras funciones como `read_excel` y `read_delim()`


### Ejercicio 18

Deshazte del mensaje de especificación de columna configurando el argumento `col_types` en `cols(a = col_double(), b = col_double(), c = col_double())`.


```{r reading-data-from-a--18, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a--18-hint-1, eval = FALSE}
read_csv("data/test_3.csv",
         col_names = (c("a", "b", "c")),
         col_types = cols(a = col_double(), 
                        b = col_double(), 
                        c = col_double()))
```

### 

El resultado cuando se ejecute tu código debería verse así:

```{r comment = ''}
read_csv("data/test_3.csv",
         col_names = (c("a", "b", "c")),
         col_types = cols(a = col_double(), 
                        b = col_double(), 
                        c = col_double()))
```

### 

Hay muchos otros argumentos para `cols`. ¡Puedes escribir `?cols` en tu consola de R para ver todos los diferentes argumentos!


### Ejercicio 19

Considera el contenido del archivo `test_5.csv`. Nota el "." para el primer valor de `b`. En este archivo, un punto indica un valor faltante. **Esto no siempre es cierto.** Los valores faltantes se pueden indicar de muchas maneras diferentes. Y, a veces, un punto es solo un punto.

```{r comment = ''}
cat(readLines("data/test_5.csv"), sep = "\n")
```

### 

Escribe código para reconocer el valor `.` para `b` en `"data/test_5.csv"` como un valor NA estableciendo el argumento `na` en "." en la llamada de la función `read_csv`.

```{r reading-data-from-a--19, exercise = TRUE}

```

```{r reading-data-from-a--19-hint-1, eval = FALSE}
Utiliza el argumento `na` y ponlo a "."
```

```{r reading-data-from-a--19-hint-2, eval = FALSE}
read_csv(file = "data/test_5.csv",
         na = ".")
```

### 

El resultado cuando se ejecute tu código debería verse así:

```{r comment = ''}
read_csv("data/test_5.csv",
         na = ".")
```

### 

Antes de eliminar el `"."`, el parámetro `col_type` de la columna b era "character", pero después se convirtió en un `double`. Un elemento puede cambiar toda la columna, lo que puede estropear otras partes de tu código.


### Ejercicio 20

Considera el contenido del archivo `test_6.csv`.

```{r comment = ''}
cat(readLines("data/test_6.csv"), sep = "\n")
```

### 

Escribe código para omitir las líneas de texto dentro de `"data/test_6.csv"` poniendo el parámetro `comment` a "#".

```{r reading-data-from-a--20, exercise = TRUE}

```

```{r reading-data-from-a--20-hint-1, eval = FALSE}
Utiliza el argumento `comment` y configúralo para que valga "#".
```

```{r reading-data-from-a--20-hint-2, eval = FALSE}
read_csv(file = "data/test_6.csv",
         comment = "...")
```

### 

El resultado cuando se ejecute tu código debería verse así:

```{r comment = ''}
read_csv("data/test_6.csv",
         comment = "#")
```

### 

No siempre tiene que ser "#", ¡puede ser cualquier carácter que designe una línea como comentario!

### Ejercicio 21

Considera el contenido del archivo `test_7.csv`.

```{r comment = ''}
cat(readLines("data/test_7.csv"), sep = "\n")
```

### 

Escribe código para asegurarte de que la columna `grade` dentro de `"data/test_7.csv"` aparece como una variable de enteros (`col_integer()`), y `student` como una variable de caracteres (`col_character()`).

```{r reading-data-from-a--21, exercise = TRUE}

```

```{r reading-data-from-a--21-hint-1, eval = FALSE}
Usa el argumento col_types y ponlo
a cols(grade = col_integer(), 
       student = col_character())
```

### 

El resultado cuando se ejecute tu código debería verse así:

```{r comment = ''}
read_csv("data/test_7.csv",
         col_types = cols(grade = col_integer(),
                          student = col_character()))
```

### 

Hay muchos más tipos de datos como `col_logical`, `col_double`, `col_date`, etc.

### Ejercicio 22

Considere el siguiente _tibble_ `tbl_1`.

```{r}
tbl_1 <- tibble(John = 1 , Aliya = 2, Maxilla = 3)
tbl_1
```

### 

<!-- AG: It seems like tutorial exercises don't store their files in the same place (at least on Windows), so I'm combining the list.files() and write_csv() so that you can see the result. -->

Usa `write_csv()` para guardar este _tibble_ en un archivo llamado "tbl_1.csv". Luego agrega `list.files()` después de esa instrucción para ver el archivo que has creado.

```{r reading-data-from-a--22, exercise = TRUE}

```

```{r reading-data-from-a--22-hint-1, eval = FALSE}
El primer argumento debe ser el objeto que deseas
guardar. El segundo argumento debe ser el nombre
con el que deseas que el archivo se guarde.
```

```{r reading-data-from-a--22-hint-2, eval = FALSE}
write_csv(...)
list.files()
```

### 

Tu resultado debería incluir dos archivos, por lo menos: `exercise.Rmd`, que es un archivo utilizado por el paquete **learnr** y `tbl_1.csv`, que es el archivo que creaste.

Hay muchos argumentos para `write_csv()` como `delim`, `na`, `col_names` y muchos más para hacer que el archivo escrito sea más limpio.

### Ejercicio 23

Considera el contenido del archivo `test_bad_names.csv`.

```{r comment = ''}
cat(readLines("data/test_bad_names.csv"), sep = "\n")
```

### 

Muchos archivos tendrán nombres de columna que no están formateados correctamente, pero **tidyverse** tiene el argumento `name_repair` para arreglar ese hecho. Usando el contenido de `"data/test_bad_names.csv"`, usa el argumento `name_repair` y ponlo a `"universal"` en la llamada a la función `read_csv()`

```{r reading-data-from-a--23, exercise = TRUE}

```

```{r reading-data-from-a--23-hint-1, eval = FALSE}
read_csv(file="data/test_bad_names.csv", name_repair="universal")
```

### 

El resultado cuando se ejecute tu código debería verse así:

```{r comment = ''}
read_csv(file = "data/test_bad_names.csv", name_repair = "universal")
```

### 

El `"universal"` se asegura de que los nombres de las columnas sean todos únicos y utiliza la sintaxis ya integrada en el comando `name_repair` para organizar los nombres. Hay otras opciones como `minimal` y `unique`, ¡pruébalas!



### Ejercicio 24

Ahora lee el archivo `"data/test_bad_names.csv"` usando `read_csv()`. Luego canalízalo a `clean_names()`, una función del paquete **janitor**.

```{r reading-data-from-a--24, exercise = TRUE}

```

```{r reading-data-from-a--24-hint-1, eval = FALSE}
read_csv(file = "data/test_bad_names.csv") |> 
  clean_names()
```

### 

El resultado cuando se ejecute tu código debería verse así:

```{r comment = ''}
read_csv(file = "data/test_bad_names.csv") |> 
  clean_names()
```

### 

La función `clean_names()` usó un algoritmo dentro del paquete **janitor** para limpiar los nombres y también hacerlos únicos. Esto te permite acceder fácilmente a las diferentes columnas sin cometer errores.

### Ejercicio 25

Para hacer que el código sea más limpio y reducir el número de canalizaciones, puedes establecer el argumento `name_repair` a `janitor::make_clean_names` en la llamada a la función `read_csv()`.

```{r reading-data-from-a--25, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-a--25-hint-1, eval = FALSE}
read_csv(file = "data/test_bad_names.csv", 
         name_repair = janitor::make_clean_names)
```

### 

El resultado cuando se ejecute tu código debería verse así:

```{r comment = ''}
read_csv(file = "data/test_bad_names.csv",
         name_repair = janitor::make_clean_names)
```

### 

El paquete **janitor** tiene una función llamada `remove_empty()` para eliminar espacios vacíos, `remove_constant()` para eliminar columnas de valores constantes y muchas más. ¡Pruébalos!



### Exercise 26

CSV files are just one type of **text** file. A text file is any file which includes plain text. The contents of such files are easy to look at in any text editor, or in RStudio.

Consider the contents of the text file `delim_1.txt`:

```{r}
cat(readLines("data/delim_1.txt"), sep = "\n")
```

### 

Write code for reading this file in to R. The values in the file are separated by pipes rather than commas. So, instead of `read_csv()`, you should use `read_delim()`. 

```{r reading-data-from-a--26, exercise = TRUE}

```

```{r reading-data-from-a--26-hint-1, eval = FALSE}
Set the file argument to "data/delim_1.txt". 
Also use the `delim` argument and set it to "|".
```

### 

El resultado cuando se ejecute tu código debería verse así:

```{r comment = ''}
read_delim("data/delim_1.txt", delim = "|")
```

### 

Note how the spaces and commas are included in the values for `town`. You can't use `read_csv()` here because not all the columns are denoted by commas.

### Exercise 27

Consider the contents of the text file `delim_2.txt`:

```{r}
cat(readLines("data/delim_2.txt"), sep = "\n")
```

### 

Write code for reading this file in to R. Also, use the `col_types` argument to both prevent the col_types message from printing out and to set `population` as an integer.

```{r reading-data-from-a--27, exercise = TRUE}

```

```{r reading-data-from-a--27-hint-1, eval = FALSE}
Set the `col_types` argument to 
cols(date = col_date(format = ""),
     population = col_integer(),
     town = col_character())
```

```{r reading-data-from-a--27-hint-2, eval = FALSE}
read_delim("data/delim_2.txt", 
           delim = "|",
           col_types = cols(date = col_date(format = ""),
                            population = col_integer(),
                            town = col_character()))
```

### 

El resultado cuando se ejecute tu código debería verse así:

```{r comment = ''}
read_delim("data/delim_2.txt", 
           delim = "|",
           col_types = cols(date = col_date(format = ""),
                            population = col_integer(),
                            town = col_character()))
```

Once you’ve mastered `read_csv()`, using **readr**’s other functions is straightforward; it’s just a matter of knowing which function to reach for.

<!-- DK: Add question about comment = "#" to drop all lines that start with (e.g.) #: -->


## Controlling column types
### 

A CSV file doesn’t contain any information about the type of each variable (i.e. whether it’s a logical, number, string, etc.), so **readr** will try to guess the type. This section describes how the guessing process works, how to resolve some common problems that cause it to fail, and, if needed, how to supply the column types yourself. 


### Exercise 1

A CSV file doesn’t contain any information about the type of each variable (i.e. whether it’s a logical, number, string, etc.), so readr will try to guess the type. This section describes how the guessing process works, how to resolve some common problems that cause it to fail, and, if needed, how to supply the column types yourself. 

In this tutorial, we will make use of the "quotation trick" which allows `read_csv()` and related functions to read data in directly from a quoted string, rather than a file. As an example, run this code:


```{r controlling-column-t-1, exercise = TRUE}
read_csv("
         a, b, c
         1, 2, 3")
```

### 

This produces the same tibble as if the character string were in a separate file which we read in.

### Exercise 2

**readr** uses a heuristic to figure out the column types. For each column, it pulls the values of 1,000 rows spaced evenly from the first row to the last, ignoring missing values. It then works through the following questions:

* Does it contain only `F`, `T`, `FALSE`, or `TRUE` (ignoring case)? If so, it’s a logical.
* Does it contain only numbers (e.g., `1`, `-4.5`, `5e6`, `Inf`)? If so, it’s a number.
* Does it match the ISO8601 standard? If so, it’s a date or date-time. 
* Otherwise, it must be a string.

You can see that behavior in action in this simple example. Press Run Code.


```{r controlling-column-t-2, exercise = TRUE}
read_csv("
  logical,numeric,date,string
  TRUE,1,2021-01-15,abc
  false,4.5,2021-02-15,def
  T,Inf,2021-02-16,ghi
")
```

### 

The first row is just treated as a column name by `read_csv()`. It does not use this information when determining variable types.


### Exercise 3

The most common way column detection fails is that a column contains unexpected values, and you get a character column instead of a more specific type. One of the most common causes for this is a missing value, recorded using something other than the `NA` that readr expects. Press Run Code.

```{r controlling-column-t-3, exercise = TRUE}
simple_csv <- "
  x
  10
  .
  20
  30"

read_csv(simple_csv)
```

### 

Note how `x` is read in as a character column when, obviously, it should be a number. In this very small case, you can easily see the missing value `.`. But what happens if you have thousands of rows with only a few missing values represented by `.`s speckled among them?

### Exercise 4

ne approach is to tell readr that x is a numeric column, and then see where it fails. You can do that with the col_types argument, which takes a named list where the names match the column names in the CSV file. Run `read_csv()` wit `simple_csv` as the first argument and `col_types = list(x = col_double()` as the second.

```{r controlling-column-t-4, exercise = TRUE}

```

```{r controlling-column-t-4-hint-1, eval = FALSE}
read_csv(
  simple_csv, 
  ... = list(x = col_double())
)
```

### 

This worked in that `x` is a `<dbl>`. R has two built-in number variable types: integers and doubles. But how can we investigate this warning?

### Exercise 5

Take the call to `read_csv()` from the previous question and assign the output to an object called `df`. Then, in the next line, run `problems()` on `df`.

```{r controlling-column-t-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r controlling-column-t-5-hint-1, eval = FALSE}
... <- read_csv(
  simple_csv, 
  col_types = list(x = col_double())
)

problems(...)
```

### 

This tells us that there was a problem in row 3, col 1 where **readr** expected a double but got a `.`. That suggests this dataset uses `.` for missing values. Real world data sets will often have many more issues but, with tools like `problems()`, you can solve them one-by-one.

### Exercise 6

Since we now that `.` means a missing value in this data, we can now call `read_csv()` on `simple_csv` with the `na` argument set to `"."`.

```{r controlling-column-t-6, exercise = TRUE}

```

```{r controlling-column-t-6-hint-1, eval = FALSE}
read_csv(simple_csv, na = ".")
```

### 

**readr** provides a total of nine column types for you to use. Here are the most important 4.

* `col_logical()` and `col_double()` read logicals and real numbers. They’re relatively rarely needed (except as above), since **readr** will usually guess them for you.

* `col_integer()` reads integers. We seldom distinguish integers and doubles because they’re functionally equivalent, but reading integers explicitly can occasionally be useful because they occupy half the memory of doubles.

* `col_character()` reads strings. This is sometimes useful to specify explicitly when you have a column that is a numeric identifier, i.e. long series of digits that identifies some object, but it doesn’t make sense to (e.g.) divide it in half, for example, a phone number, social security number, credit card number, etc.


### Exercise 7

It’s also possible to override the default column by switching from `list()` to `cols()` and specifying `.default`. Use `read_csv()` to read in `another_csv` with the `cols_type` argumet set to `cols(.default = col_character()`.

```{r controlling-column-t-7, exercise = TRUE}
another_csv <- "
x,y,z
1,2,3"


```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r controlling-column-t-7-hint-1, eval = FALSE}
read_csv(
  another_csv, 
  ... = cols(... = col_character())
)
```

### 

 
Here are the other 5 column types from **readr**.

* `col_factor()`, `col_date()`, and `col_datetime()` create factors, dates, and date-times respectively.

* `col_number()` is a permissive numeric parser that will ignore non-numeric components, and is particularly useful for currencies.

* `col_skip()` skips a column so it’s not included in the result, which can be useful for speeding up reading the data if you have a large CSV file and you only want to use some of the columns.

### Exercise 8

Another useful helper is `cols_only()` which will read in only the columns you specify. Run `read_csv()` on `another_csv` with the `col_types` argument set to `cols_only(x = col_character()`.


```{r controlling-column-t-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r controlling-column-t-8-hint-1, eval = FALSE}
read_csv(
  another_csv,
  col_types = ...(x = ...)
)
```

### 

The [help page](https://readr.tidyverse.org/reference/cols.html) for `cols()` includes more details and discussion.



<!-- OLD STUFF BELOW -->

### Exercise 9

<!-- DK: Lots of clean from here to end of section. Knowledge drops! -->

Consider another example file:

```{r controlling-column-t-9-setup}
cat(readLines("data/ex_2.csv"), sep = "\n")
```

Read the `data/ex_2.csv` file into R to check if there are any parsing mistakes.

```{r controlling-column-t-9, exercise = TRUE}

```

```{r controlling-column-t-9-hint-1, eval = FALSE}
read_csv("data/ex_2.csv")
```

### 

Notice that R parses column `a` and `b` both as a doubles. But what if column `a` should be parsed as an integer and column `b` should be parsed as a date?

### Exercise 10

```{r controlling-column-t-10-setup}
cat(readLines("data/ex_2.csv"), sep = "\n")
```

Begin by using `read_csv()` to read in the file `ex_2.csv`. Then, set the `col_types` argument to `cols()`. Within `cols()`, set `.default` to `col_character()`.

```{r controlling-column-t-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r controlling-column-t-10-hint-1, eval = FALSE}
read_csv(..., 
         col_types = cols(.default = ...)
)
```

### Exercise 11

```{r controlling-column-t-11-setup}
cat(readLines("data/ex_2.csv"), sep = "\n")
```

Pipe the results of `read_csv()` to the function `mutate()`. Within `mutate()` set `a` to `parse_integer(a)`. 

```{r controlling-column-t-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r controlling-column-t-11-hint-1, eval = FALSE}
... |> 
    mutate(a = ...)
```

### 

You can also use `parse_number()` to parse integers, not just `parse_integer()`.

### Exercise 12

```{r controlling-column-t-12-setup}
cat(readLines("data/ex_2.csv"), sep = "\n")
```

Continue your pipe with `mutate()`. Use `parse_date()` to transform `b` to dates. The first argument to `parse_date()` should be `b`. The second argument should be `format`. Set `format` to `"%Y%M%D"`.

```{r controlling-column-t-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r controlling-column-t-12-hint-1, eval = FALSE}
... |> 
  mutate(b = parse_date(b, format="..."))
```

### 

`"%Y%M%D"` tells R to read the number as a date (Y for year, M for month, D for date). 

### Exercise 13

Let's explore one last file `ex_3.csv` that has parsing failures.

```{r controlling-column-t-13-setup}
cat(readLines("data/ex_3.csv"), sep = "\n")
```

 Run `read_csv("data/ex_3.csv")` and examine the parsing failures.

```{r controlling-column-t-13, exercise = TRUE}

```

```{r controlling-column-t-13-hint-1, eval = FALSE}
read_csv("data/ex_3.csv")
```

### 

What are the problems here? First, R parses column `x` as a character, when it is clearly a date. Also, column `z` should be parsed as an integer not a character!

### Exercise 14

```{r controlling-column-t-14-setup}
cat(readLines("data/ex_3.csv"), sep = "\n")
```

Let's first fix column `x`. Pipe the results of `read_csv("data/ex_3.csv")` to the function `mutate()`. Within `mutate()` set `x` to `parse_date(x, "%d %B %Y")`.  

```{r controlling-column-t-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r controlling-column-t-14-hint-1, eval = FALSE}
... |> 
    mutate(x = ...)
```

### 

The `%d` signifies that there's only 1 digit for the day, the `%B` means that we're using the name of the month rather than the number, and the spaces in between represent the spaces in between each value. By customizing our format string, we can easily parse any format of dates without any problems.

Also note that we did not need to use the `.default = col_character()` trick before we used `mutate()`. Why? Because R already read all of the columns as characters to begin with.

### Exercise 15

```{r controlling-column-t-15-setup}
cat(readLines("data/ex_3.csv"), sep = "\n")
```

Continue your pipe with `mutate()`. Within `mutate()` set `z` to `parse_integer(z)`. 

```{r controlling-column-t-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r controlling-column-t-15-hint-1, eval = FALSE}
... |> 
    mutate(z = ...)
```

## Reading data from multiple files
### 

Data Scientists deal with a huge number of files loaded with data, so it is important to learn how to clean multiple files at once.

### Exercise 1

Run `list.files("data")` to check what files there are in the `data` folder.

```{r reading-data-from-mu-1, exercise = TRUE}

```

```{r reading-data-from-mu-1-hint-1, eval = FALSE}
list.files("data")
```

### 

The `list.files()` function is part of base R.  Check out its [help page](https://stat.ethz.ch/R-manual/R-devel/library/base/html/list.files.html).

### Exercise 2

Change the call to `list.files("data")` by setting the argument `pattern` to `"similar"` to only look at the files with the names "similar" in them.

```{r reading-data-from-mu-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-mu-2-hint-1, eval = FALSE}
list.files("data", ... = "similar")
```

### 

El resultado cuando se ejecute tu código debería verse así:

```{r}
list.files("data", pattern = "similar")
```

### 

You can also set `pattern` to ".csv" or ".delim" for those types of files in a folder.

### Exercise 3

To show the exact directory of where the files came from, set the argument `full.names` to `TRUE` in `list.files()`.

```{r reading-data-from-mu-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-mu-3-hint-1, eval = FALSE}
list.files("data", pattern = "similar", full.names = ...)
```

### 

El resultado cuando se ejecute tu código debería verse así:

```{r}
list.files("data", pattern = "similar", full.names = TRUE)
```

### Exercise 4

These are the contents of `similar_1.csv`, `similar_2.csv`, `similar_3.csv`, respectively.

```{r}
cat(readLines("data/similar_1.csv"), sep = "\n")
cat(readLines("data/similar_2.csv"), sep = "\n")
cat(readLines("data/similar_3.csv"), sep = "\n")
```

### 

Now let's combine the files by piping the last call to `list_files()` directly to `read_csv()`!

```{r reading-data-from-mu-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-mu-4-hint-1, eval = FALSE}
list.files("data", pattern = "similar", full.names = TRUE) |> 
  read_csv()
```

### 

Column `b`'s type is `chr` because the "." in `similar_1.csv` makes R think the rest of the column are characters. We will fix that using the `na` argument in `read_csv()`.

### Exercise 5

In `read_csv()`, set the argument `na` to `"."` to get rid of the character in column `b`.

```{r reading-data-from-mu-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-mu-5-hint-1, eval = FALSE}
... |> 
  read_csv(na = ".")
```

### 

El resultado cuando se ejecute tu código debería verse así:

```{r}
list.files("data", pattern = "similar", full.names = TRUE) |> 
  read_csv(na = ".")
```

### 

Because the "." is gone, column `b`'s type is `dbl` now. 

### Exercise 6

Now let's get rid of the annoying "specify column types" message by using the `show_col_types` argument. In the call to `read_csv()`, add the `show_col_types` argument to `FALSE`.

```{r reading-data-from-mu-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-mu-6-hint-1, eval = FALSE}
... |> 
  read_csv(na = ".", ... = FALSE)
```

### 

You can use the other arguments of `read_csv()` to further clean your files, such as `col_names`, `col_types`, or `skip`. 

### Exercise 7

 
Consider the three sales files currently in the `data` directory. Run `list.files()` with `"data"` as the `path` (first) argument and `"sales"` as the value for the `pattern` argument.

```{r reading-data-from-mu-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-mu-7-hint-1, eval = FALSE}
list.files(path = ..., 
           pattern = ...)
```

### 

Although there are only 3 files here, in many cases you will need to deal with hundreds or even thousands of files.

### Exercise 8

Pipe the results from `list_files()` to `read_csv()`. Don't forget to add `full.names = TRUE` to the call to `list.files()`, otherwise `read_csv()` won't be able to *find* the files.


```{r reading-data-from-mu-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-mu-8-hint-1, eval = FALSE}
list.files(path = "data",
           pattern = 'sales', 
           full.names = TRUE) |> 
  read_csv()
```

### 

<!-- DK: Might be better to use an example without month, which does tell us which file! Just change the text files to remove the month column.  -->

Although this works, we have lost the information about which rows come from which input files.

### Exercise 9

Using the same code as above, add the `id` argument to `read_csv()` with a value of `"file"`.

```{r reading-data-from-mu-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r reading-data-from-mu-9-hint-1, eval = FALSE}
list.files(path = "data",
           pattern = 'sales', 
           full.names = TRUE) |> 
  read_csv(... = "file")
```

### 

This is especially helpful in circumstances where the files you’re reading in do not have an identifying column that can help you trace the observations back to their original sources. It is often useful to know the "provenance" of a given piece of data. If something seems wrong later in the process, we will want to track it back to its original source.



## Writing to a file
### 

**readr** also comes with two useful functions for writing data back to disk: `write_csv()` and `write_tsv()`. The most important arguments to these functions are `x` (the data frame to save) and `file` (the location to save it). You can also specify how missing values are written with `na`, and if you want to `append` to an existing file.

### Exercise 1

Let's first create a new R object, `estudiantes2` which is the result of the clean up we did above on the original "students.csv" file. Press Run Code.

```{r writing-to-a-file-1, exercise = TRUE}
estudiantes2 <- estudiantes |> 
  clean_names() |> 
  mutate(
    meal_plan = factor(meal_plan),
    age = if_else(age == "five", "5", age),
    age = parse_number(age)
  )
```

### 

This workflow is very common. First, we interactively add code, line-by-line, to a pipe, running the entire pipe each time, examining the output as it is "spat" back to the scrren. Second, once the pipe produces what we want, then we add an object, `estudiantes2` in this case, to the front of the pipe and create a permanent object which we can then work with.

### Exercise 2

Type `student2` and hit Run Code. This will produce the same output as `print(estudiantes2)`. That is, hitting Return on an R object is the same thing as explicitly printing that object.

```{r writing-to-a-file-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r writing-to-a-file-2-hint-1, eval = FALSE}
estudiantes2
```

### 

`estudiantes2` has been cleaned up from the original "students.csv", most importantly in terms the variable names. Note that `mean_plan` is a `<fct>`, meaning a factor.



### Exercise 3

Use `write_csv()` to write the contents of the `estudiantes2` object to a file called `"estudiantes2.csv"`. Do this by setting the first argument of `write_csv()`, `x`, to `estudiantes2` and then the second argument, `file`, to `"estudiantes2.csv"`.


```{r writing-to-a-file-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r writing-to-a-file-3-hint-1, eval = FALSE}
write_csv(x = ..., 
          ... = "estudiantes2.csv")
```

### 

As with many commonly used functions, we will often drop the argument names. In that case, we would typically write `write_csv(estudiantes2, "estudiantes2.csv")`.

### Exercise 4

Now let’s read that csv file back in. Run `read_csv()` on `"estudiantes2.csv"`.


```{r writing-to-a-file-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r writing-to-a-file-4-hint-1, eval = FALSE}
read_csv("estudiantes2.csv")
```

### 

Note that variable type information is lost when you save to CSV because you’re starting over by reading from a plain text file again. `meal_plan` is now `<chr>`, meaning a character variable.

This makes CSVs a little unreliable for caching interim results --- you need to recreate the column specification every time you load in. There are two main alternative: `write_rds()` with`read_rds()` and `write_parquet()`

### Exercise 5

RDS files store R objects in a file which can be saved on your computer. Then, if you come back to a project, even after restarting R, you can quickly load back the object, without redoing all the code which created it.

Consider the following plot.

```{r}
iris |> 
  ggplot(aes(x = Sepal.Length, y = Sepal.Width)) +
  geom_jitter() +
  labs(title = "Sepal Dimensions of Various Species of Iris",
       x = "Sepal Length",
       y = "Sepal Width")
```

### 

We have saved the plot for you to an object named `iris_p`. On the line 8, use `write_rds()` to save this plot to a file named "test_1.rds". *Note*: Nothing will be displayed for you to see.


```{r writing-to-a-file-5, exercise = TRUE}
iris_p <- iris |> 
  ggplot(aes(x = Sepal.Length, y = Sepal.Width)) +
  geom_jitter() +
  labs(title = "Sepal Dimensions of Various Species of Iris",
       x = "Sepal Length",
       y = "Sepal Width")

```

```{r writing-to-a-file-5-hint-1, eval = FALSE}
The first argument should be the object you want to save. 
The second argument should be the name you want the 
file saved as.
```

```{r writing-to-a-file-5-hint-2, eval = FALSE}
write_rds(iris_p, 
          "test_1.rds")
```

### 

The big advantage of creating an rds file is that we can reload the object it contains later, without re-running the code which created it.  

### Exercise 6

Run `list.files("data")`. You should see your newly created file listed.

```{r writing-to-a-file-6, exercise = TRUE}

```

```{r writing-to-a-file-6-hint-1, eval = FALSE}
list.files("data")
```

### 

To find the file on your computer, you can set the `list.files()` argument `include.dirs` to `TRUE`. This causes the full path for each file to be returned.

### Exercise 7

Let's now use `read_rds()` to read in the newly created file! Set the `file` argument to `"data/test_1.rds"`.

```{r writing-to-a-file-7, exercise = TRUE}

```

```{r writing-to-a-file-7-hint-1, eval = FALSE}
read_rds(file = "data/test_1.rds")
```

### 

Plots are just one example of what we can store in a rds file. We can also store datasets.

### Exercise 8

Consider the following dataset.

```{r}
glimpse(mtcars)
```

### 

Use `write_rds()` to save `mtcars` to a file named `test_2.rds`.

```{r writing-to-a-file-8, exercise = TRUE}

```

```{r writing-to-a-file-8-hint-1, eval = FALSE}
The first argument should be the object you want to save. 
The second argument should be the name you want the 
file saved as.
```

```{r writing-to-a-file-8-hint-2, eval = FALSE}
write_rds(mtcars, "test_2.rds")
```

### 

You are not limited to just one object in an rds file. You can save multiple!

### Exercise 9

Run `list.files("data")`. You should see your newly created file listed.

```{r writing-to-a-file-9, exercise = TRUE}

```

```{r writing-to-a-file-9-hint-1, eval = FALSE}
list.files("data")
```

### 

You can use `append` with `write_csv()` and similar text-basedd functions to add on data to an existing file. That won't work with `write_rds()` and other functions which work with binary data. In that case, the files must be recreated each time.


### Exercise 10

Let's now use `read_rds()` to read in the newly created file! Set the `file` argument to `"data/test_2.rds"`.

```{r writing-to-a-file-10, exercise = TRUE}

```

```{r writing-to-a-file-10-hint-1, eval = FALSE}
read_rds(file = "data/test_2.rds")
```

### 

`write_rds()` and `read_rds()` are the most commonly used approaches for saving/using R objects.

### Exercise 11

`write_rds()` and `read_rds()` are not the best approach for working with large data sets. In that case, use the functions `write_parquet()` and  `read_parquet()` from the [**arrow**](https://arrow.apache.org/) package.

Copy/paste any question from the [Apache Arrow](https://arrow.apache.org/) FAQ below.


```{r writing-to-a-file-11}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edita la Respuesta",
	incorrect = NULL,
	rows = 10)
```

### 

Parquet tends to be much faster than RDS and is usable outside of R, but does require the **arrow** package.



## Data entry
### 

Sometimes you’ll need to assemble a tibble “by hand” doing a little data entry in your R script. There are two useful functions to help you do this which differ in whether you layout the tibble by columns (`tibble()`) or by rows (`tribble()`).

### Exercise 1

Create a tibble by using the `tibble()` function. Pass three arguments to `tibble()`, which are the three variables you want to include in the new tibble: `x = c(1, 2, 5)`, `y = c("h", "m", "g")`, and `z = c(0.08, 0.83, 0.60)`. Don't forget to separate input arguments with commas.


```{r data-entry-1, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r data-entry-1-hint-1, eval = FALSE}
tibble(
  x = ..., 
  ... = c("h", "m", "g"),
  ... = ...
)
```

### 

Laying out the data by column can make it hard to see how the rows are related, so an alternative is `tribble()`, short for transposed tibble, which lets you lay out your data row by row.

### Exercise 2

Use `tribble()` to create the same tibble as in the previous question. Use the Hint to get started.

```{r data-entry-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r data-entry-2-hint-1, eval = FALSE}
tribble(
  ~x, ..., ~z,
  1, "h", ...,
  2, ..., 0.83,
  5, "g", ...
)
```

### 

The difference between the name `tibble()` and the name `tribble()` is one letter: *r*. The *r* stands for **r**ows since `tribble()` allows you to type in the data by row.

<!-- More questions: Something about going to data frames with as.data.frame? Differences between tibbles and data frames? How about as_tibble()? Maybe matrices? -->

## Summary
### 

This tutorial covered [Chapter 8: Data import](https://r4ds.hadley.nz/data-import.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. You learned how to import data into your R project using [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.html) and related functions from the [**readr**](https://readr.tidyverse.org/) package. You also learned how to write out data to files with functions like [`write_csv()`](https://readr.tidyverse.org/reference/write_delim.html).

The **[janitor](https://sfirke.github.io/janitor/)** package includes a variety of useful functions, especially [`clean_names()`](https://sfirke.github.io/janitor/reference/clean_names.html).

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
